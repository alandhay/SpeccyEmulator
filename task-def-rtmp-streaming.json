{
  "family": "spectrum-emulator-dev",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "1024",
  "memory": "2048",
  "executionRoleArn": "arn:aws:iam::043309319786:role/spectrum-emulator-ecs-TaskExecutionRole-wCrluMDhLRXJ",
  "containerDefinitions": [
    {
      "name": "spectrum-emulator",
      "image": "ubuntu:22.04",
      "essential": true,
      "portMappings": [
        {
          "containerPort": 8765,
          "protocol": "tcp"
        },
        {
          "containerPort": 8080,
          "protocol": "tcp"
        }
      ],
      "environment": [
        {
          "name": "ENVIRONMENT",
          "value": "dev"
        },
        {
          "name": "DISPLAY",
          "value": ":99"
        },
        {
          "name": "DEBIAN_FRONTEND",
          "value": "noninteractive"
        }
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/spectrum-emulator-dev",
          "awslogs-region": "us-east-1",
          "awslogs-stream-prefix": "ecs"
        }
      },
      "command": [
        "/bin/bash",
        "-c",
        "cat > /tmp/setup.sh << 'SCRIPT_EOF'\n#!/bin/bash\nset -e\necho 'Starting ZX Spectrum Emulator with RTMP streaming...'\napt-get update\napt-get install -y python3 python3-pip curl xvfb fuse-emulator-sdl ffmpeg pulseaudio\npip3 install websockets aiohttp\necho 'Dependencies installed successfully'\nexport DISPLAY=:99\necho 'Starting Xvfb...'\nXvfb :99 -screen 0 256x192x24 &\nsleep 3\necho 'Starting PulseAudio...'\npulseaudio --start --exit-idle-time=-1 &\necho 'Starting RTMP-enabled emulator server...'\npython3 -c \"\nimport asyncio, websockets, json, logging, subprocess, threading, time, os, signal\nfrom aiohttp import web\nfrom pathlib import Path\nfrom aiohttp.web import FileResponse\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nclass SpectrumEmulator:\n    def __init__(self):\n        self.connected_clients = set()\n        self.emulator_process = None\n        self.web_stream_process = None\n        self.rtmp_stream_process = None\n        self.stream_dir = Path('/tmp/stream')\n        self.stream_dir.mkdir(exist_ok=True)\n        self.streaming_to_platforms = False\n        self.youtube_key = None\n        self.twitch_key = None\n    \n    def start_emulator(self):\n        try:\n            if self.emulator_process:\n                logger.info('Emulator already running')\n                return True\n            logger.info('Starting FUSE ZX Spectrum emulator')\n            self.emulator_process = subprocess.Popen(['fuse-sdl', '--machine', '48', '--graphics-filter', 'none', '--sound', '--no-confirm-actions'], env={'DISPLAY': ':99'})\n            time.sleep(3)\n            self.start_web_stream()\n            logger.info('ZX Spectrum emulator started successfully')\n            return True\n        except Exception as e:\n            logger.error(f'Failed to start emulator: {e}')\n            self.stop_emulator()\n            return False\n    \n    def start_web_stream(self):\n        '''Start HLS stream for web interface'''\n        try:\n            logger.info('Starting web HLS stream')\n            stream_file = self.stream_dir / 'stream.m3u8'\n            self.web_stream_process = subprocess.Popen([\n                'ffmpeg', '-f', 'x11grab', '-video_size', '256x192', '-framerate', '25', '-i', ':99.0',\n                '-c:v', 'libx264', '-preset', 'ultrafast', '-tune', 'zerolatency', '-g', '25',\n                '-f', 'hls', '-hls_time', '1', '-hls_list_size', '3',\n                '-hls_flags', 'delete_segments+append_list',\n                '-hls_segment_filename', str(self.stream_dir / 'segment_%03d.ts'),\n                str(stream_file)\n            ])\n            logger.info('Web HLS streaming started')\n            return True\n        except Exception as e:\n            logger.error(f'Failed to start web stream: {e}')\n            return False\n    \n    def start_rtmp_streaming(self, youtube_key=None, twitch_key=None):\n        '''Start RTMP streaming to YouTube/Twitch'''\n        try:\n            if self.rtmp_stream_process:\n                logger.info('RTMP streaming already active')\n                return True\n            \n            # Build RTMP destinations\n            destinations = []\n            if youtube_key:\n                destinations.append(f'[f=flv]rtmp://a.rtmp.youtube.com/live2/{youtube_key}')\n                self.youtube_key = youtube_key\n            if twitch_key:\n                destinations.append(f'[f=flv]rtmp://live.twitch.tv/live/{twitch_key}')\n                self.twitch_key = twitch_key\n            \n            if not destinations:\n                logger.error('No streaming keys provided')\n                return False\n            \n            tee_output = '|'.join(destinations)\n            \n            logger.info(f'Starting RTMP stream to {len(destinations)} platform(s)')\n            \n            # RTMP streaming optimized for platforms\n            self.rtmp_stream_process = subprocess.Popen([\n                'ffmpeg', '-f', 'x11grab', '-video_size', '256x192', '-framerate', '25', '-i', ':99.0',\n                '-f', 'pulse', '-i', 'default',  # Audio input\n                '-c:v', 'libx264', '-preset', 'fast', '-tune', 'zerolatency',\n                '-b:v', '800k', '-maxrate', '800k', '-bufsize', '1600k',\n                '-pix_fmt', 'yuv420p', '-g', '50',  # Keyframe every 2 seconds\n                '-c:a', 'aac', '-b:a', '128k', '-ar', '44100',\n                '-f', 'tee', f'map=0 {tee_output}'\n            ])\n            \n            self.streaming_to_platforms = True\n            logger.info('RTMP streaming to platforms started!')\n            return True\n            \n        except Exception as e:\n            logger.error(f'Failed to start RTMP streaming: {e}')\n            return False\n    \n    def stop_rtmp_streaming(self):\n        '''Stop RTMP streaming'''\n        if self.rtmp_stream_process:\n            try:\n                self.rtmp_stream_process.terminate()\n                self.rtmp_stream_process.wait(timeout=5)\n            except subprocess.TimeoutExpired:\n                self.rtmp_stream_process.kill()\n            self.rtmp_stream_process = None\n            self.streaming_to_platforms = False\n            logger.info('RTMP streaming stopped')\n    \n    def stop_emulator(self):\n        logger.info('Stopping emulator and all streams')\n        \n        # Stop RTMP streaming\n        self.stop_rtmp_streaming()\n        \n        # Stop web streaming\n        if self.web_stream_process:\n            try:\n                self.web_stream_process.terminate()\n                self.web_stream_process.wait(timeout=5)\n            except subprocess.TimeoutExpired:\n                self.web_stream_process.kill()\n            self.web_stream_process = None\n        \n        # Stop emulator\n        if self.emulator_process:\n            try:\n                self.emulator_process.terminate()\n                self.emulator_process.wait(timeout=5)\n            except subprocess.TimeoutExpired:\n                self.emulator_process.kill()\n            self.emulator_process = None\n        \n        logger.info('All processes stopped')\n    \n    async def handle_websocket(self, websocket):\n        logger.info(f'New WebSocket client connected')\n        self.connected_clients.add(websocket)\n        try:\n            await websocket.send(json.dumps({\n                'type': 'connected', \n                'message': 'Connected to ZX Spectrum Emulator Server', \n                'emulator_running': self.emulator_process is not None,\n                'streaming_to_platforms': self.streaming_to_platforms\n            }))\n            async for message in websocket:\n                try:\n                    data = json.loads(message)\n                    await self.handle_message(websocket, data)\n                except json.JSONDecodeError:\n                    logger.error(f'Invalid JSON received: {message}')\n        except websockets.exceptions.ConnectionClosed:\n            logger.info('WebSocket client disconnected')\n        except Exception as e:\n            logger.error(f'WebSocket error: {e}')\n        finally:\n            self.connected_clients.discard(websocket)\n    \n    async def handle_message(self, websocket, data):\n        message_type = data.get('type')\n        logger.info(f'Received message: {message_type}')\n        \n        if message_type == 'start_emulator':\n            success = self.start_emulator()\n            await websocket.send(json.dumps({\n                'type': 'emulator_status', \n                'running': success, \n                'message': 'Emulator started successfully' if success else 'Failed to start emulator'\n            }))\n            \n        elif message_type == 'stop_emulator':\n            self.stop_emulator()\n            await websocket.send(json.dumps({\n                'type': 'emulator_status', \n                'running': False, \n                'message': 'Emulator stopped'\n            }))\n            \n        elif message_type == 'start_streaming':\n            youtube_key = data.get('youtube_key')\n            twitch_key = data.get('twitch_key')\n            success = self.start_rtmp_streaming(youtube_key, twitch_key)\n            await websocket.send(json.dumps({\n                'type': 'streaming_status',\n                'streaming': success,\n                'message': 'Started streaming to platforms' if success else 'Failed to start streaming'\n            }))\n            \n        elif message_type == 'stop_streaming':\n            self.stop_rtmp_streaming()\n            await websocket.send(json.dumps({\n                'type': 'streaming_status',\n                'streaming': False,\n                'message': 'Stopped streaming to platforms'\n            }))\n            \n        elif message_type == 'key_press':\n            key = data.get('key')\n            if key:\n                logger.info(f'Key pressed: {key}')\n                await websocket.send(json.dumps({\n                    'type': 'key_response', \n                    'key': key, \n                    'message': f'Key {key} sent to emulator'\n                }))\n                \n        elif message_type == 'status':\n            await websocket.send(json.dumps({\n                'type': 'status_response',\n                'emulator_running': self.emulator_process is not None,\n                'web_stream_active': self.web_stream_process is not None,\n                'rtmp_streaming': self.streaming_to_platforms,\n                'connected_clients': len(self.connected_clients)\n            }))\n            \n        else:\n            await websocket.send(json.dumps({\n                'type': 'error', \n                'message': f'Unknown message type: {message_type}'\n            }))\n    \n    async def health_check(self, request):\n        return web.Response(text='OK', status=200)\n    \n    async def serve_stream_file(self, request):\n        filename = request.match_info['filename']\n        file_path = self.stream_dir / filename\n        if file_path.exists():\n            if filename.endswith('.m3u8'):\n                return FileResponse(file_path, headers={\n                    'Content-Type': 'application/vnd.apple.mpegurl', \n                    'Cache-Control': 'no-cache',\n                    'Access-Control-Allow-Origin': '*'\n                })\n            elif filename.endswith('.ts'):\n                return FileResponse(file_path, headers={\n                    'Content-Type': 'video/mp2t', \n                    'Cache-Control': 'no-cache',\n                    'Access-Control-Allow-Origin': '*'\n                })\n        return web.Response(status=404)\n    \n    async def start_server(self):\n        app = web.Application()\n        app.router.add_get('/health', self.health_check)\n        app.router.add_get('/stream/{filename}', self.serve_stream_file)\n        runner = web.AppRunner(app)\n        await runner.setup()\n        site = web.TCPSite(runner, '0.0.0.0', 8080)\n        await site.start()\n        logger.info('HTTP server started on port 8080 with RTMP streaming support')\n        server = await websockets.serve(self.handle_websocket, '0.0.0.0', 8765)\n        logger.info('WebSocket server started on port 8765')\n        logger.info('ZX Spectrum Emulator ready for YouTube/Twitch streaming!')\n        try:\n            await server.wait_closed()\n        except KeyboardInterrupt:\n            logger.info('Server shutdown requested')\n        finally:\n            self.cleanup()\n    \n    def cleanup(self):\n        logger.info('Cleaning up resources')\n        self.stop_emulator()\n\nemulator = SpectrumEmulator()\n\ndef signal_handler(signum, frame):\n    logger.info(f'Received signal {signum}')\n    emulator.cleanup()\n    exit(0)\n\nsignal.signal(signal.SIGTERM, signal_handler)\nsignal.signal(signal.SIGINT, signal_handler)\n\nasyncio.run(emulator.start_server())\n\"\nSCRIPT_EOF\nchmod +x /tmp/setup.sh && /tmp/setup.sh"
      ]
    }
  ]
}
